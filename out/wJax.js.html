<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>JSDoc: Source: wJax.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link
      type="text/css"
      rel="stylesheet"
      href="styles/prettify-tomorrow.css"
    />
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css" />
  </head>

  <body>
    <div id="main">
      <h1 class="page-title">Source: wJax.js</h1>

      <section>
        <article>
          <pre class="prettyprint source linenums"><code>const wJax = {
  xhr: window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(),
  send: send,
  sucsess: sucsess,
  setTimeOut: setTimeOut,
  send_promise: send_promise,
  then: then,
  cache: Cache
};
/**
 * 发起请求
 * @param {JSON} config 请求配置文件
 * @param {String} methord http请求
 * @param {String} url 请求地址
 * @param {JSON} data 要传输的数据
 * @param {boolean} sync 同步或者异步，默认异步
 * @param {Number} timeOut 超时，默认100ms
 */
function send(config) {
  let { methord, url, data, sync = true, timeOut = 100 } = config;
  methord = methord.toLowerCase();
  let formdata = new FormData();
  if (methord == "get") {
    let arr = [];
    for (let k in data) {
      let ser = `${k}=${data[k]}`;
      arr.push(ser);
    }
    !url.includes("?")
      ? (url = `${url}?${arr.join("&amp;")}`)
      : (url = `${url}${arr.join("&amp;")}`);
  } else if (methord == "post")
    for (let val in data) {
      formdata.append(val, data[val]);
    }
  else throw new Error("HTTP Methord Error");
  this.setTimeOut(timeOut);
  this.xhr.open(methord, url, sync);
  try {
    if (methord == "get") this.xhr.send(null);
    else if (methord == "post") this.xhr.send(formdata);
  } catch (error) {
    this.error = error;
  }
  return this;
}
/**
 * 发送请求之后的回调函数
 * @param {callback} reslove 发送请求之后的回调函数
 */
function sucsess(reslove) {
  this.xhr.onreadystatechange = () => {
    if (this.xhr.readyState == 4 &amp;&amp; this.xhr.status == 200) {
      reslove(this.xhr.responseText);
    }
  };
  return this;
}
/**
 * 设置超时时间
 * @param {Number} timeOut 超时时间
 */
function setTimeOut(timeOut) {
  this.xhr.timeOut = timeOut;
  this.xhr.ontimeout = () => {
    console.log("请求超时");
  };
}
/**
 * 结果返回promise对象
 */
function send_promise(methord, url, data, sync = true, timeOut = 5000) {
  let promise = new Promise((reslove, reject) => {
    try {
      this.send(methord, url, data, (sync = true), (timeOut = 5000));
      this.sucsess(reslove);
    } catch (error) {
      reject(error);
    }
  });
  return promise;
}
/**
 *实现类似promise对象的操作，使用then方法来进行对回调函数的拆分
 * @param {Function} reslove 成功时执行的回调函数
 * @param {Function} reject 失败时执行的回调函数
 */
function then(reslove, reject) {
  if (!this.error) {
    this.sucsess(reslove);
  } else {
    reject(this.error);
  }
  return this;
}
/**
 * 捕获全局的异常，在回调函数中进行输出
 * @param {Function} error 捕获异常时执行的回调函数
 */
function Catch(error) {
  if (this.error) error(this.error);
  else return null;
}
</code></pre>
        </article>
      </section>
    </div>

    <nav>
      <h2><a href="index.html">Home</a></h2>
      <h3>Global</h3>
      <ul>
        <li><a href="global.html#Catch">Catch</a></li>
        <li><a href="global.html#send">send</a></li>
        <li><a href="global.html#send_promise">send_promise</a></li>
        <li><a href="global.html#setTimeOut">setTimeOut</a></li>
        <li><a href="global.html#sucsess">sucsess</a></li>
        <li><a href="global.html#then">then</a></li>
      </ul>
    </nav>

    <br class="clear" />

    <footer>
      Documentation generated by
      <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Dec 30
      2018 19:40:21 GMT+0800 (GMT+08:00)
    </footer>

    <script>
      prettyPrint();
    </script>
    <script src="scripts/linenumber.js"></script>
  </body>
</html>
